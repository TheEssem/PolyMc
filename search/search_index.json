{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PolyMc \u00b6 PolyMc aims to be a compatibility layer between a modded server and the vanilla client. Allowing already existing mods to add blocks, items and other content without having to install the mod. The advantage of PolyMc is to separate the serverside mechanics from the hacks needed to display the mod on the client. PolyMc doesn't edit anything serverside, this means that mods adding blocks genuinely add those blocks, they'll have their own namespace and everything. It is only on the packet level that that block gets replaced with the block used for the client PolyMc is compatible with Fabric and Quilt and is licensed under the LGPL . You can find the source code here .","title":"PolyMc"},{"location":"#polymc","text":"PolyMc aims to be a compatibility layer between a modded server and the vanilla client. Allowing already existing mods to add blocks, items and other content without having to install the mod. The advantage of PolyMc is to separate the serverside mechanics from the hacks needed to display the mod on the client. PolyMc doesn't edit anything serverside, this means that mods adding blocks genuinely add those blocks, they'll have their own namespace and everything. It is only on the packet level that that block gets replaced with the block used for the client PolyMc is compatible with Fabric and Quilt and is licensed under the LGPL . You can find the source code here .","title":"PolyMc"},{"location":"blockstates/","text":"Unused Block States \u00b6 Note This page is purely to document all unused block states in Minecraft, which might be useful to explain PolyMc's behaviour or might help if you're doing some serverside hackery yourself. What to pay attention to \u00b6 Render layer Collision box Selection box Whether the state is waterlogged or not All of these blocks are unused on the client. This means that different states don't have different textures. The properties are probably still used on the server. So it's important that you can still differentiate these on the server. (PolyMc does this by only working in the packet layer, none of the blocks inside the world are actually touched, they're just regular (modded) blocks). Note The number of blocks here usually represents the amount of states unless noted otherwise with a *. Warning This table has a bunch of information, I have no doubt made a mistake somewhere in here. If you notice any, or if there's an entry missing, please let me know. Block # of blocks Used in PolyMc Renderlayer Notes Noteblocks 799 standard Note blocks only require a small bit of code to make sure the particles still work. All of their properties are only needed on the server, the client will still play the correct note even if it doesn't know the states. Needs resynchronizing when the block below changes. Beenest/Beehive 24 standard Beehives/nests only have a different texture for no honey and full honey. Target block 15 standard The block needs resynchronization when hit with an arrow. Dispenser/dropper 12 standard The client doesn't need to know whether the block is powered or not. Infested blocks 9 standard Infested blocks look the same as their un-infested counterparts. Copper blocks 4 standard Waxed copper blocks can be replaced with their unwaxed block states. Snowy mycelium/podzol 2 standard Snowy mycelium and podzol display the same as a snowy grass block Jukebox 1 standard There's a has_record property that the client doesn't need to care about. Tnt 1 3 standard Tnt has an unstable property that the client doesn't need to care about. Note that tnt is instantly breakable, which might cause trouble if you're doing server-side block breaking. Double slabs 52 standard Double slabs have the same texture as their full block counterpart. The smooth stone double slab is the only exception to this. Waterlogged double slabs 53 standard These states are completely unused. Note that they will create water drip particles. Petrified oak slab 1* standard Unlike the double slab states, this one can be used for actual slabs instead of just full blocks. Waxed copper slab 4* standard Unlike the double slab states, this one can be used for actual slabs instead of just full blocks. Waxed copper blocks can be replaced with their unwaxed block states. The \"# of blocks\" represents the number of slabs you can make. Sculk sensors 60 cut-out Sculk sensors have a power propery that the client doesn't need to care about. Note that the \"active\" states produce particles and are emmisive. Sculk sensors have the same collisions as a lower half slab. Half of these states are waterlogged. Leaves 234 cut-out mipped Leaves have the advantage of not culling the blocks around them. All of their properties are not needed by the client. Half of these states are waterlogged, this isn't very noticeable though, as leaves are full blocks. They might produce particles Chorus Flower 4 cut-out Age 0 through 4 have the same texture. Chorus flower blocks have a full cube hitbox. Chorus Plant 17 cut-out The state without any connections and the states where both up and down are connected and any of the other sides of connected are impossible to achieve. They have weird hitboxes but they're mostly a full cube. Kelp 25 cut-out All of the states are waterlogged. Saplings 6 cut-out Saplings are blocks without collisions that have a large selection box. Their stage is only needed on the server. Sugarcane 15 cut-out Is coloured depending on the biome. Small dripleaf 6 cut-out The lower part of the dripleaf doesn't care about direction. Half of these are waterlogged. Tripwire 96 translucent (kinda) The client doesn't need to know if string is powered or detached. Needs resynchronizing if the block next to it changes and if that would change the string's state. Tripwire hooks 4 cut-out mipped The powered but not attached property is unused (TODO: confirm this). The block does have an unusual selection box. Cave vines 50 2 cut-out The age isn't needed on the client. Note that this block is climbable. Twisting/weeping vines 50 cut-out These vines have an age property that the client doesn't need to care about. Note that the blocks are climbable. Plants ? 5 cut-out Certain plants (carrots, nether wart, etc) have certain age levels that don't have a separate texture. Buttons 32 standard Buttons facing north/south or east/west are the same when placed on the floor/ceiling. Fence gate 144 standard The client does not need to know whether the fence gate is powered or not. There are also some duplicate states for some directions. 64 of these states are open, making them usable as a block without collision. Doors 30* 1 cut-out The client does not need to know whether the door is powered or not. There are also some duplicate states, an open door to the north can be represented by a closed door to the west. Note that iron doors will behave differently. The \"# of blocks\" represents the amount of custom doors you can make here, as it doesn't make sense to list the amount of block states. Trapdoors 10* cut-out The client does not need to know whether the trapdoor is powered or not. Note that iron trapdoors will behave differently. The \"# of blocks\" represents the amount of custom trapdoors you can make here, as it doesn't make sense to list the amount of block states. Waxed copper stairs 4* standard Waxed copper blocks can be replaced with their unwaxed block states. The \"# of blocks\" represents the number of stairs you can make. Weighted pressure plates 28 standard There's a power level from 0-15, but there's only a texture for powered and unpowered. Farmland 6 standard Farmland has a collision box that makes it useful for paths, they're just lower than a full block. There's a moisture level from 0-7, but there's only a texture for unmoistured and moistured. Bamboo 1* 5 cut-out Bamboo has an age level that the client doesn't need to care about. This allows for 1 custom bamboo block. Cactus 15 cut-out Cacti have an age property that the client doesn't need to care about. They have an odd collision box though. Daylight detectors 30 5 standard Daylight detectors have a powered property that the client doesn't need to care about. End portal frame 4 5 standard End portal frames orientated north/south and east/west look the same. Scaffolding 28 5 cut-out Scaffolding has a distance property that the client doesn't need to care about. Scaffolding does have weird movement properties and is climbable. Half of the states are waterlogged. Redstone 8 5 cut-out Redstone has some unused states pointing in only one direction. Unfortunately power levels above 0 can't be used due to particles. They also have a weird selection box and are instantly breakable. Not a great block to work with. Hopper 1* 5 standard The client doesn't have to know whether the hopper is powered or not. This allows for 1 custom hopper. Bell 1* 5 standard The bell has a powered property that the client doesn't need to care about. This allows for 1 custom bell. Note that the bell itself is rendered with a ber. Lectern 1* 5 standard The lectern has a powered property that the client doesn't need to care about. This allows for 1 custom lectern. Stairs ? standard Stairs technically have some duplicate states, for example a stair facing north with a connection on the left is the same as a stair facing east with a connection on the right. They're not that useful. Walls 22* 4 standard Walls have a bunch of weird states, including one without selection box and collision box (like air). I'm sure they're useful for some specific cases but they're a very odd block. The \"# of blocks\" represents the amount of different wall variants. Beds 32 5 cut-out Beds have an occupied property that the client doesn't care about. Note that beds are implemented using block entity renderers so you can only really add to the block. Only the powered state is currently implemented. \u21a9 Only cave vines without berries are used due to synchronization issues \u21a9 Currently disabled due to issues with tnt being instantly breakable. \u21a9 Only implemented for the air-like case. There are others, but they're a very odd shape. So it's not really worth it. \u21a9 Tracked in #145 . \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Unused Block States"},{"location":"blockstates/#unused-block-states","text":"Note This page is purely to document all unused block states in Minecraft, which might be useful to explain PolyMc's behaviour or might help if you're doing some serverside hackery yourself.","title":"Unused Block States"},{"location":"blockstates/#what-to-pay-attention-to","text":"Render layer Collision box Selection box Whether the state is waterlogged or not All of these blocks are unused on the client. This means that different states don't have different textures. The properties are probably still used on the server. So it's important that you can still differentiate these on the server. (PolyMc does this by only working in the packet layer, none of the blocks inside the world are actually touched, they're just regular (modded) blocks). Note The number of blocks here usually represents the amount of states unless noted otherwise with a *. Warning This table has a bunch of information, I have no doubt made a mistake somewhere in here. If you notice any, or if there's an entry missing, please let me know. Block # of blocks Used in PolyMc Renderlayer Notes Noteblocks 799 standard Note blocks only require a small bit of code to make sure the particles still work. All of their properties are only needed on the server, the client will still play the correct note even if it doesn't know the states. Needs resynchronizing when the block below changes. Beenest/Beehive 24 standard Beehives/nests only have a different texture for no honey and full honey. Target block 15 standard The block needs resynchronization when hit with an arrow. Dispenser/dropper 12 standard The client doesn't need to know whether the block is powered or not. Infested blocks 9 standard Infested blocks look the same as their un-infested counterparts. Copper blocks 4 standard Waxed copper blocks can be replaced with their unwaxed block states. Snowy mycelium/podzol 2 standard Snowy mycelium and podzol display the same as a snowy grass block Jukebox 1 standard There's a has_record property that the client doesn't need to care about. Tnt 1 3 standard Tnt has an unstable property that the client doesn't need to care about. Note that tnt is instantly breakable, which might cause trouble if you're doing server-side block breaking. Double slabs 52 standard Double slabs have the same texture as their full block counterpart. The smooth stone double slab is the only exception to this. Waterlogged double slabs 53 standard These states are completely unused. Note that they will create water drip particles. Petrified oak slab 1* standard Unlike the double slab states, this one can be used for actual slabs instead of just full blocks. Waxed copper slab 4* standard Unlike the double slab states, this one can be used for actual slabs instead of just full blocks. Waxed copper blocks can be replaced with their unwaxed block states. The \"# of blocks\" represents the number of slabs you can make. Sculk sensors 60 cut-out Sculk sensors have a power propery that the client doesn't need to care about. Note that the \"active\" states produce particles and are emmisive. Sculk sensors have the same collisions as a lower half slab. Half of these states are waterlogged. Leaves 234 cut-out mipped Leaves have the advantage of not culling the blocks around them. All of their properties are not needed by the client. Half of these states are waterlogged, this isn't very noticeable though, as leaves are full blocks. They might produce particles Chorus Flower 4 cut-out Age 0 through 4 have the same texture. Chorus flower blocks have a full cube hitbox. Chorus Plant 17 cut-out The state without any connections and the states where both up and down are connected and any of the other sides of connected are impossible to achieve. They have weird hitboxes but they're mostly a full cube. Kelp 25 cut-out All of the states are waterlogged. Saplings 6 cut-out Saplings are blocks without collisions that have a large selection box. Their stage is only needed on the server. Sugarcane 15 cut-out Is coloured depending on the biome. Small dripleaf 6 cut-out The lower part of the dripleaf doesn't care about direction. Half of these are waterlogged. Tripwire 96 translucent (kinda) The client doesn't need to know if string is powered or detached. Needs resynchronizing if the block next to it changes and if that would change the string's state. Tripwire hooks 4 cut-out mipped The powered but not attached property is unused (TODO: confirm this). The block does have an unusual selection box. Cave vines 50 2 cut-out The age isn't needed on the client. Note that this block is climbable. Twisting/weeping vines 50 cut-out These vines have an age property that the client doesn't need to care about. Note that the blocks are climbable. Plants ? 5 cut-out Certain plants (carrots, nether wart, etc) have certain age levels that don't have a separate texture. Buttons 32 standard Buttons facing north/south or east/west are the same when placed on the floor/ceiling. Fence gate 144 standard The client does not need to know whether the fence gate is powered or not. There are also some duplicate states for some directions. 64 of these states are open, making them usable as a block without collision. Doors 30* 1 cut-out The client does not need to know whether the door is powered or not. There are also some duplicate states, an open door to the north can be represented by a closed door to the west. Note that iron doors will behave differently. The \"# of blocks\" represents the amount of custom doors you can make here, as it doesn't make sense to list the amount of block states. Trapdoors 10* cut-out The client does not need to know whether the trapdoor is powered or not. Note that iron trapdoors will behave differently. The \"# of blocks\" represents the amount of custom trapdoors you can make here, as it doesn't make sense to list the amount of block states. Waxed copper stairs 4* standard Waxed copper blocks can be replaced with their unwaxed block states. The \"# of blocks\" represents the number of stairs you can make. Weighted pressure plates 28 standard There's a power level from 0-15, but there's only a texture for powered and unpowered. Farmland 6 standard Farmland has a collision box that makes it useful for paths, they're just lower than a full block. There's a moisture level from 0-7, but there's only a texture for unmoistured and moistured. Bamboo 1* 5 cut-out Bamboo has an age level that the client doesn't need to care about. This allows for 1 custom bamboo block. Cactus 15 cut-out Cacti have an age property that the client doesn't need to care about. They have an odd collision box though. Daylight detectors 30 5 standard Daylight detectors have a powered property that the client doesn't need to care about. End portal frame 4 5 standard End portal frames orientated north/south and east/west look the same. Scaffolding 28 5 cut-out Scaffolding has a distance property that the client doesn't need to care about. Scaffolding does have weird movement properties and is climbable. Half of the states are waterlogged. Redstone 8 5 cut-out Redstone has some unused states pointing in only one direction. Unfortunately power levels above 0 can't be used due to particles. They also have a weird selection box and are instantly breakable. Not a great block to work with. Hopper 1* 5 standard The client doesn't have to know whether the hopper is powered or not. This allows for 1 custom hopper. Bell 1* 5 standard The bell has a powered property that the client doesn't need to care about. This allows for 1 custom bell. Note that the bell itself is rendered with a ber. Lectern 1* 5 standard The lectern has a powered property that the client doesn't need to care about. This allows for 1 custom lectern. Stairs ? standard Stairs technically have some duplicate states, for example a stair facing north with a connection on the left is the same as a stair facing east with a connection on the right. They're not that useful. Walls 22* 4 standard Walls have a bunch of weird states, including one without selection box and collision box (like air). I'm sure they're useful for some specific cases but they're a very odd block. The \"# of blocks\" represents the amount of different wall variants. Beds 32 5 cut-out Beds have an occupied property that the client doesn't care about. Note that beds are implemented using block entity renderers so you can only really add to the block. Only the powered state is currently implemented. \u21a9 Only cave vines without berries are used due to synchronization issues \u21a9 Currently disabled due to issues with tnt being instantly breakable. \u21a9 Only implemented for the air-like case. There are others, but they're a very odd shape. So it's not really worth it. \u21a9 Tracked in #145 . \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"What to pay attention to"},{"location":"config/","text":"Config \u00b6 Disabled mixins \u00b6 This is a way to disable specific mixins within PolyMc. Doing this isn\u2019t recommended unless you know what the mixins do. Most mixins have an explanation in their javadoc. resource pack misc \u00b6 processSyncedBlockEventServerSide \u00b6 The server can send a block event packet to a client. This instructs the client to execute an event on that location. This is used for example with note blocks to make the sound and spawn the particle. This config has a list of blocks in the namespace:block format. The block event for those block will be executed on the server instead of the client. The results of this will vary per block. (The block event is specified in the Block#onSyncedBlockEvent) remapVanillaBlockIds \u00b6 This will ensure vanilla blocks keep the right ids. Switch this to true if a mod is messing up the ids, and you want it not to be messed up. enableWizardThreading \u00b6 Executes wizard updates on a different thread. This is experimental and will crash at this point in time. If you don't use add-on mods that add wizard you don't need to worry about this. maxPacketsPerSecond \u00b6 Provides a rough estimate of the maximum amount of packets that should be sent per second. This isn't a hard limit.","title":"Config"},{"location":"config/#config","text":"","title":"Config"},{"location":"config/#disabled-mixins","text":"This is a way to disable specific mixins within PolyMc. Doing this isn\u2019t recommended unless you know what the mixins do. Most mixins have an explanation in their javadoc. resource pack","title":"Disabled mixins"},{"location":"config/#misc","text":"","title":"misc"},{"location":"config/#processsyncedblockeventserverside","text":"The server can send a block event packet to a client. This instructs the client to execute an event on that location. This is used for example with note blocks to make the sound and spawn the particle. This config has a list of blocks in the namespace:block format. The block event for those block will be executed on the server instead of the client. The results of this will vary per block. (The block event is specified in the Block#onSyncedBlockEvent)","title":"processSyncedBlockEventServerSide"},{"location":"config/#remapvanillablockids","text":"This will ensure vanilla blocks keep the right ids. Switch this to true if a mod is messing up the ids, and you want it not to be messed up.","title":"remapVanillaBlockIds"},{"location":"config/#enablewizardthreading","text":"Executes wizard updates on a different thread. This is experimental and will crash at this point in time. If you don't use add-on mods that add wizard you don't need to worry about this.","title":"enableWizardThreading"},{"location":"config/#maxpacketspersecond","text":"Provides a rough estimate of the maximum amount of packets that should be sent per second. This isn't a hard limit.","title":"maxPacketsPerSecond"},{"location":"faq/","text":"FAQ \u00b6 Does this work with Bedrock/GeyserMc? \u00b6 tl;dr: no. The way bedrock works is quite different from Java. The hacks PolyMc does won't work well for Bedrock. I believe Geyser has a way to convert resource packs, so you might have some luck with that. Ideally a separate mod would be created that handles Bedrock clients, considering Bedrock actually supports custom blocks/items/entities, such a mod should work really well. Unfortunately nobody actually has had the time to make it. Why is this block stone? \u00b6 PolyMc might not be able to handle the collision shape of the block, or PolyMc might have run out of blocks. See the limitations page .","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#does-this-work-with-bedrockgeysermc","text":"tl;dr: no. The way bedrock works is quite different from Java. The hacks PolyMc does won't work well for Bedrock. I believe Geyser has a way to convert resource packs, so you might have some luck with that. Ideally a separate mod would be created that handles Bedrock clients, considering Bedrock actually supports custom blocks/items/entities, such a mod should work really well. Unfortunately nobody actually has had the time to make it.","title":"Does this work with Bedrock/GeyserMc?"},{"location":"faq/#why-is-this-block-stone","text":"PolyMc might not be able to handle the collision shape of the block, or PolyMc might have run out of blocks. See the limitations page .","title":"Why is this block stone?"},{"location":"getting_started/","text":"Getting started with PolyMc \u00b6 Installation \u00b6 async function downloadLatest() { var apiData = await fetch(\"https://api.github.com/repos/TheEpicBlock/PolyMc/releases/latest\") window.location = (await apiData.json()).assets[0].browser_download_url } PolyMc is a normal mod and can be installed into the mods folder. Download latest version View all versions Generating the resource pack \u00b6 PolyMc requires a resource pack to be installed on the client to function 1 . You can generate the resource pack by running the /polymc generate resources command. It will appear in the root of your server in a folder named resource . How you distribute the resource pack is up to you. Warning Please check if you have the legal right to redistribute the assets of the mods you\u2019re using. Need help, info or support? \u00b6 Check the #PolyMc channel in the Fabric Serverside Development discord! It\u2019s technically possible to use PolyMc without a resource pack, but you'd have to use the api for that. \u21a9","title":"Getting started with PolyMc"},{"location":"getting_started/#getting-started-with-polymc","text":"","title":"Getting started with PolyMc"},{"location":"getting_started/#installation","text":"async function downloadLatest() { var apiData = await fetch(\"https://api.github.com/repos/TheEpicBlock/PolyMc/releases/latest\") window.location = (await apiData.json()).assets[0].browser_download_url } PolyMc is a normal mod and can be installed into the mods folder. Download latest version View all versions","title":"Installation"},{"location":"getting_started/#generating-the-resource-pack","text":"PolyMc requires a resource pack to be installed on the client to function 1 . You can generate the resource pack by running the /polymc generate resources command. It will appear in the root of your server in a folder named resource . How you distribute the resource pack is up to you. Warning Please check if you have the legal right to redistribute the assets of the mods you\u2019re using.","title":"Generating the resource pack"},{"location":"getting_started/#need-help-info-or-support","text":"Check the #PolyMc channel in the Fabric Serverside Development discord! It\u2019s technically possible to use PolyMc without a resource pack, but you'd have to use the api for that. \u21a9","title":"Need help, info or support?"},{"location":"limitations/","text":"Limitations of PolyMc \u00b6 Note PolyMc only affects what the client sees. The behaviour of things should always just work\u2122. PolyMc attempts to automatically convert blocks and items into things a vanilla client can understand. This may or may not actually work, depending on the mod. The only real way to know if a mod will work is to: Here's a list of what PolyMc can approximately do. Note These aren't guarantees, sometimes mods do wierd stuff. Items \u00b6 All items should work perfectly fine. You might encounter issues with items that use custom renders or edit their appearance with custom properties. Blocks \u00b6 Your mileage will vary depending on the collision shape of the block. It kinda has to match up with what the client thinks. PolyMc uses block states that go unused on the client side to display modded blocks. This means there's a limit to how many blocks can be added. Here's an approximate, non-exhaustive, list of how many unused block states each collision shape has: Full blocks: 971 Uncollidable blocks: 139 (can go up to 283) Doors: 9 Trapdoors: 9 Path blocks: 5 Slabs: 5 Stairs: 4 Recipes \u00b6 Recipes are fully functional. The data PolyMc sends to the recipe book will include the right nbt to display it properly. One caveat is that the recipe book's autofill doesn't care for nbt, so when filling in modded items it might get it wrong. PolyMc attempts to mitigate this by using as many different items as possible. Sounds \u00b6 Custom sounds should totally work. Enchantments \u00b6 Custom enchantments should totally work. Gui's \u00b6 Kinda. By default, you'll just get a chest which contains the slots of the original gui. It's not pretty but it works. If your gui has buttons, or more slots than a chest, you're out of luck currently. The system here can totally be made smarter, but I don't have the time. Entities \u00b6 PolyMc attempts to guess what entity looks kind of similar to the modded one. Often, this will be completely wrong. Unfortunately, there's not much else PolyMc can do here due to the way that entities are defined. You can look at the api if you need to specify entities further. Breaking speeds \u00b6 PolyMc automatically switches to calculating the breaking speed of custom blocks and items on the server when needed. This means the client will receive mining fatigue and PolyMc will provide the breaking animation instead, so custom tools and blocks will work fine with PolyMc. Breaking modded stuff might be slightly more annoying with high ping but that hasn't been much of an issue so far.","title":"Limitations of PolyMc"},{"location":"limitations/#limitations-of-polymc","text":"Note PolyMc only affects what the client sees. The behaviour of things should always just work\u2122. PolyMc attempts to automatically convert blocks and items into things a vanilla client can understand. This may or may not actually work, depending on the mod. The only real way to know if a mod will work is to: Here's a list of what PolyMc can approximately do. Note These aren't guarantees, sometimes mods do wierd stuff.","title":"Limitations of PolyMc"},{"location":"limitations/#items","text":"All items should work perfectly fine. You might encounter issues with items that use custom renders or edit their appearance with custom properties.","title":"Items"},{"location":"limitations/#blocks","text":"Your mileage will vary depending on the collision shape of the block. It kinda has to match up with what the client thinks. PolyMc uses block states that go unused on the client side to display modded blocks. This means there's a limit to how many blocks can be added. Here's an approximate, non-exhaustive, list of how many unused block states each collision shape has: Full blocks: 971 Uncollidable blocks: 139 (can go up to 283) Doors: 9 Trapdoors: 9 Path blocks: 5 Slabs: 5 Stairs: 4","title":"Blocks"},{"location":"limitations/#recipes","text":"Recipes are fully functional. The data PolyMc sends to the recipe book will include the right nbt to display it properly. One caveat is that the recipe book's autofill doesn't care for nbt, so when filling in modded items it might get it wrong. PolyMc attempts to mitigate this by using as many different items as possible.","title":"Recipes"},{"location":"limitations/#sounds","text":"Custom sounds should totally work.","title":"Sounds"},{"location":"limitations/#enchantments","text":"Custom enchantments should totally work.","title":"Enchantments"},{"location":"limitations/#guis","text":"Kinda. By default, you'll just get a chest which contains the slots of the original gui. It's not pretty but it works. If your gui has buttons, or more slots than a chest, you're out of luck currently. The system here can totally be made smarter, but I don't have the time.","title":"Gui's"},{"location":"limitations/#entities","text":"PolyMc attempts to guess what entity looks kind of similar to the modded one. Often, this will be completely wrong. Unfortunately, there's not much else PolyMc can do here due to the way that entities are defined. You can look at the api if you need to specify entities further.","title":"Entities"},{"location":"limitations/#breaking-speeds","text":"PolyMc automatically switches to calculating the breaking speed of custom blocks and items on the server when needed. This means the client will receive mining fatigue and PolyMc will provide the breaking animation instead, so custom tools and blocks will work fine with PolyMc. Breaking modded stuff might be slightly more annoying with high ping but that hasn't been much of an issue so far.","title":"Breaking speeds"},{"location":"api/","text":"The PolyMc api \u00b6 The PolyMc api allows you to use PolyMc's systems to edit the way PolyMc behaves. If a mod already works fine with PolyMc, you don't need to implement anything using the api. But if certain things don't work, you might be able to use the api to fix those manually. After all, not everything can be automated. There are also certain functions inside PolyMc that are only available via the api. Notably the wizard system . If you've got any questions about the api, don't hesitate to ask them in the #PolyMc channel of the Fabric Serverside Development discord. Importing PolyMc \u00b6 PolyMc's versioning scheme is {polymc-version}+{mc-version} . You can look here for a list of versions. repositories { maven { url \"https://maven.theepicblock.nl\" content { includeGroup ( \"nl.theepicblock\" ) } } } dependencies { modImplementation \"nl.theepicblock:PolyMc:VERSION\" } Entrypoint \u00b6 PolyMc provides an entry point for you to interact with it. Implement PolyMcEntrypoint and add it to your fabric.mod.json : { \"entrypoints\" : { \"polymc\" : [ \"io.github.theepicblock.ExampleEntrypoint\" ] } }","title":"The PolyMc api"},{"location":"api/#the-polymc-api","text":"The PolyMc api allows you to use PolyMc's systems to edit the way PolyMc behaves. If a mod already works fine with PolyMc, you don't need to implement anything using the api. But if certain things don't work, you might be able to use the api to fix those manually. After all, not everything can be automated. There are also certain functions inside PolyMc that are only available via the api. Notably the wizard system . If you've got any questions about the api, don't hesitate to ask them in the #PolyMc channel of the Fabric Serverside Development discord.","title":"The PolyMc api"},{"location":"api/#importing-polymc","text":"PolyMc's versioning scheme is {polymc-version}+{mc-version} . You can look here for a list of versions. repositories { maven { url \"https://maven.theepicblock.nl\" content { includeGroup ( \"nl.theepicblock\" ) } } } dependencies { modImplementation \"nl.theepicblock:PolyMc:VERSION\" }","title":"Importing PolyMc"},{"location":"api/#entrypoint","text":"PolyMc provides an entry point for you to interact with it. Implement PolyMcEntrypoint and add it to your fabric.mod.json : { \"entrypoints\" : { \"polymc\" : [ \"io.github.theepicblock.ExampleEntrypoint\" ] } }","title":"Entrypoint"},{"location":"api/blocks/","text":"Block polys \u00b6 Block polys take in the servers sided blockstates and output one to be displayed on the client. This can be any vanilla block you'd like. If your block kinda resembles a wool block, you can make it look like a wool block. Usually you'd want to add some distinction to it though. Wool block example public void registerPolys ( PolyRegistry registry ) { registry . registerBlockPoly ( customStone , new SimpleReplacementPoly ( Blocks . WHITE_WOOL . getDefaultState ())) } Wizards \u00b6 You can attach a wizard to a block to summon entities or particles at it. See the section on wizards . The BlockStateManager \u00b6 Minecraft has a limited amount of unused blockstates. Any block we want to be displayed on the client needs a blockstate. The BlockStateManager has the job of tracking what blockstates are available for blocks to use. Requests can be made to the BlockStateManager to get a blockstate of specific profile and then the BlockStateManager will attempt to get an available blockstate for you. To get the BlockStateManager, use PolyRegistry.getSharedValues(BlockStateManager.KEY) . Block Profiles \u00b6 TODO","title":"Block polys"},{"location":"api/blocks/#block-polys","text":"Block polys take in the servers sided blockstates and output one to be displayed on the client. This can be any vanilla block you'd like. If your block kinda resembles a wool block, you can make it look like a wool block. Usually you'd want to add some distinction to it though. Wool block example public void registerPolys ( PolyRegistry registry ) { registry . registerBlockPoly ( customStone , new SimpleReplacementPoly ( Blocks . WHITE_WOOL . getDefaultState ())) }","title":"Block polys"},{"location":"api/blocks/#wizards","text":"You can attach a wizard to a block to summon entities or particles at it. See the section on wizards .","title":"Wizards"},{"location":"api/blocks/#the-blockstatemanager","text":"Minecraft has a limited amount of unused blockstates. Any block we want to be displayed on the client needs a blockstate. The BlockStateManager has the job of tracking what blockstates are available for blocks to use. Requests can be made to the BlockStateManager to get a blockstate of specific profile and then the BlockStateManager will attempt to get an available blockstate for you. To get the BlockStateManager, use PolyRegistry.getSharedValues(BlockStateManager.KEY) .","title":"The BlockStateManager"},{"location":"api/blocks/#block-profiles","text":"TODO","title":"Block Profiles"},{"location":"api/entities/","text":"Entities \u00b6 Entity polys extend EntityPoly . This poly is basically just a factory for a Wizard . Wizards are explained in greater detail here , they allow you to summon other vanilla entities to represent your modded one and can also do other things like sending particles. It's recommended to extend EntityWizard instead of Wizard to make your life easier. For an example, check out MissingEntityPoly , which is the default entity poly. It simply spawns a barrier item to let people know that there's an entity there but PolyMc can't display it.","title":"Entities"},{"location":"api/entities/#entities","text":"Entity polys extend EntityPoly . This poly is basically just a factory for a Wizard . Wizards are explained in greater detail here , they allow you to summon other vanilla entities to represent your modded one and can also do other things like sending particles. It's recommended to extend EntityWizard instead of Wizard to make your life easier. For an example, check out MissingEntityPoly , which is the default entity poly. It simply spawns a barrier item to let people know that there's an entity there but PolyMc can't display it.","title":"Entities"},{"location":"api/guis/","text":"Guis \u00b6 The PolyMc gui api allows you to replace any modded screenhandler with your own. This allows you to do pretty much anything with the slots. Gui polys can be registered like any other poly using the PolyRegistry#registerGuiPoly function. public class ExampleGuiPoly implements GuiPoly { @Override public ScreenHandler replaceScreenHandler ( ScreenHandler base , ServerPlayerEntity player , int syncId ) { return new ExampleScreenHandler ( ScreenHandlerType . GENERIC_9X3 , syncId , player . getInventory (), base ); } public static class ExampleScreenHandler extends ScreenHandler { protected final ScreenHandler base ; protected ExampleScreenHandler ( ScreenHandlerType <?> type , int syncId , PlayerInventory playerInventory , ScreenHandler base ) { this . base = base ; for ( int y = 0 ; y < 9 ; ++ y ) { for ( int x = 0 ; x < 3 ; ++ x ) { this . addSlot ( new StaticSlot ( new ItemStack ( Items . BLACK_STAINED_GLASS_PANE ))); } } //Player inventory for ( int y = 0 ; y < 3 ; ++ y ) { for ( int x = 0 ; x < 9 ; ++ x ) { this . addSlot ( new Slot ( playerInventory , x + y * 9 + 9 , 8 + x * 18 , 84 + y * 18 )); } } //Player hotbar for ( int hotbar = 0 ; hotbar < 9 ; ++ hotbar ) { this . addSlot ( new Slot ( playerInventory , hotbar , 8 + hotbar * 18 , 142 )); } } @Override public ItemStack transferSlot ( PlayerEntity player , int index ) { // For this example, you've got to make sure the indexes align with those from the base screenhandler. This depends on what screenhandler is your base. base . transferSlot ( player , index - x ); } } } Using SGui (recommended) \u00b6 It quickly gets tedious to write your own screenhandlers. SGui is a small library that's much better for making serverside gui's. You can use SGui in a GuiPoly by opening your gui via SGui like normal and then returning null to prevent PolyMc from opening any other screenhandlers. public class SGuiExample implements GuiPoly { @Override public ScreenHandler replaceScreenHandler ( ScreenHandler base , ServerPlayerEntity player , int syncId ) { var gui = new SimpleGui ( ScreenHandlerType . GENERIC_3X3 , player , false ); gui . setTitle ( Text . literal ( \"SGui test\" )); gui . open (); return null ; } }","title":"Guis"},{"location":"api/guis/#guis","text":"The PolyMc gui api allows you to replace any modded screenhandler with your own. This allows you to do pretty much anything with the slots. Gui polys can be registered like any other poly using the PolyRegistry#registerGuiPoly function. public class ExampleGuiPoly implements GuiPoly { @Override public ScreenHandler replaceScreenHandler ( ScreenHandler base , ServerPlayerEntity player , int syncId ) { return new ExampleScreenHandler ( ScreenHandlerType . GENERIC_9X3 , syncId , player . getInventory (), base ); } public static class ExampleScreenHandler extends ScreenHandler { protected final ScreenHandler base ; protected ExampleScreenHandler ( ScreenHandlerType <?> type , int syncId , PlayerInventory playerInventory , ScreenHandler base ) { this . base = base ; for ( int y = 0 ; y < 9 ; ++ y ) { for ( int x = 0 ; x < 3 ; ++ x ) { this . addSlot ( new StaticSlot ( new ItemStack ( Items . BLACK_STAINED_GLASS_PANE ))); } } //Player inventory for ( int y = 0 ; y < 3 ; ++ y ) { for ( int x = 0 ; x < 9 ; ++ x ) { this . addSlot ( new Slot ( playerInventory , x + y * 9 + 9 , 8 + x * 18 , 84 + y * 18 )); } } //Player hotbar for ( int hotbar = 0 ; hotbar < 9 ; ++ hotbar ) { this . addSlot ( new Slot ( playerInventory , hotbar , 8 + hotbar * 18 , 142 )); } } @Override public ItemStack transferSlot ( PlayerEntity player , int index ) { // For this example, you've got to make sure the indexes align with those from the base screenhandler. This depends on what screenhandler is your base. base . transferSlot ( player , index - x ); } } }","title":"Guis"},{"location":"api/guis/#using-sgui-recommended","text":"It quickly gets tedious to write your own screenhandlers. SGui is a small library that's much better for making serverside gui's. You can use SGui in a GuiPoly by opening your gui via SGui like normal and then returning null to prevent PolyMc from opening any other screenhandlers. public class SGuiExample implements GuiPoly { @Override public ScreenHandler replaceScreenHandler ( ScreenHandler base , ServerPlayerEntity player , int syncId ) { var gui = new SimpleGui ( ScreenHandlerType . GENERIC_3X3 , player , false ); gui . setTitle ( Text . literal ( \"SGui test\" )); gui . open (); return null ; } }","title":"Using SGui (recommended)"},{"location":"api/items/","text":"Item polys \u00b6 The default poly generation for items works really well, so I don't know why you'd want to make a custom item poly. But I'm not here to judge. One basic thing you might want to do is to use a different base item for your modded item. This is easy enough: public void registerPolys ( PolyRegistry registry ) { registry . registerItemPoly ( moddedItem , new CustomModelDataPoly ( registery . getCMDManager (), moddedItem , Items . DIAMOND_SWORD )) } Note If your item is damageable, use DamageableItemPoly instead of CustomModelDataPoly . If you want to create your own item poly, you should implement the ItemPoly interface. Never modify the input itemstack directly, always make a copy before doing so. Global item polys \u00b6 Global item polys are applied to all items before they are sent to the client. Global item polys implement ItemTransformer and can be registered using PolyRegistry#registerGlobalItemPoly. Keep in mind that, like normal item polys, global item polys should never modify the input itemstack directly. The CustomModelDataManager \u00b6 The CMD manager is made to prevent polys from using the same CMD values on the same items. At the simplest level, you can request a CMD value to use for a specific item. You can also request a number of values, the number returned is the first value you may use, see the javadoc for more detail. The CMD manager can also round-robin from a list of items. This is the preferred way of doing things as this prevents recipe conflicts (the recipe book doesn\u2019t take the CMD value into account, this isn\u2019t a huge deal but is a minor annoyance to clients). To get the CustomModelDataManager, use PolyRegistry.getSharedValues(CustomModelDataManager.KEY) .","title":"Item polys"},{"location":"api/items/#item-polys","text":"The default poly generation for items works really well, so I don't know why you'd want to make a custom item poly. But I'm not here to judge. One basic thing you might want to do is to use a different base item for your modded item. This is easy enough: public void registerPolys ( PolyRegistry registry ) { registry . registerItemPoly ( moddedItem , new CustomModelDataPoly ( registery . getCMDManager (), moddedItem , Items . DIAMOND_SWORD )) } Note If your item is damageable, use DamageableItemPoly instead of CustomModelDataPoly . If you want to create your own item poly, you should implement the ItemPoly interface. Never modify the input itemstack directly, always make a copy before doing so.","title":"Item polys"},{"location":"api/items/#global-item-polys","text":"Global item polys are applied to all items before they are sent to the client. Global item polys implement ItemTransformer and can be registered using PolyRegistry#registerGlobalItemPoly. Keep in mind that, like normal item polys, global item polys should never modify the input itemstack directly.","title":"Global item polys"},{"location":"api/items/#the-custommodeldatamanager","text":"The CMD manager is made to prevent polys from using the same CMD values on the same items. At the simplest level, you can request a CMD value to use for a specific item. You can also request a number of values, the number returned is the first value you may use, see the javadoc for more detail. The CMD manager can also round-robin from a list of items. This is the preferred way of doing things as this prevents recipe conflicts (the recipe book doesn\u2019t take the CMD value into account, this isn\u2019t a huge deal but is a minor annoyance to clients). To get the CustomModelDataManager, use PolyRegistry.getSharedValues(CustomModelDataManager.KEY) .","title":"The CustomModelDataManager"},{"location":"api/misc/","text":"Misc \u00b6 Shared Values \u00b6 The PolyRegistry keeps track of certain shared values. For example, the CustomModelDataManager . Shared values allow you to allocate things like CMD values, blockstates, or specific colours of armor. You could also use shared values to, for example, generate a models for every block in the game, and then you can reuse these models across your polys. It's rare for you to want to create your own shared value, but if you do want to do it, you'll need to create a SharedValuesKey . This key contains a builder for your class, which will contain all the data you want to store, and a resource factory. That last one requires a bit more explanation, in general shared values are stored only in the PolyRegistry and are thrown away once the registration phase is done. (You should never keep a reference to a shared value). But you might want to use your data to generate resources. In that case you do want to keep the information needed to generate those resources. The resource factory should take in your shared values and return a class which only contains the information needed for resource generation. If you don't need resource generation, simply use null , you can also take a look at ArmorColorManager for an example. For ArmorColorManager all of the info is still needed during resource gen so the resource factory simply returns itself.","title":"Misc"},{"location":"api/misc/#misc","text":"","title":"Misc"},{"location":"api/misc/#shared-values","text":"The PolyRegistry keeps track of certain shared values. For example, the CustomModelDataManager . Shared values allow you to allocate things like CMD values, blockstates, or specific colours of armor. You could also use shared values to, for example, generate a models for every block in the game, and then you can reuse these models across your polys. It's rare for you to want to create your own shared value, but if you do want to do it, you'll need to create a SharedValuesKey . This key contains a builder for your class, which will contain all the data you want to store, and a resource factory. That last one requires a bit more explanation, in general shared values are stored only in the PolyRegistry and are thrown away once the registration phase is done. (You should never keep a reference to a shared value). But you might want to use your data to generate resources. In that case you do want to keep the information needed to generate those resources. The resource factory should take in your shared values and return a class which only contains the information needed for resource generation. If you don't need resource generation, simply use null , you can also take a look at ArmorColorManager for an example. For ArmorColorManager all of the info is still needed during resource gen so the resource factory simply returns itself.","title":"Shared Values"},{"location":"api/polymaps/","text":"PolyMaps \u00b6 The PolyMap is what stores all the polys that PolyMc uses. These Polys in turn define how different things are transformed. By default, PolyMc will generate a single PolyMap using the PolyRegistry . This acts as a builder for the PolyMap. You can add stuff to the PolyRegistry via the registerPolys method in your entrypoint. After the entrypoint is called, PolyMc will iterate the registries and attempt to auto generate polys for anything that doesn't have them. Custom PolyMaps \u00b6 You can actually assign different PolyMaps to different players. The PolyMap used for a player is determined by the PolyMapProvider.EVENT event. example PolyMapProvider . EVENT . register ( player -> { if ( isSpecial ( player )) { return MY_SPECIAL_POLYMAP ; } else { return null ; } }); Using this feature you can also completely disable PolyMc for a player. This is done by returning a NOPPolyMap . Other uses for this include, for example, a PolyMap that doesn't use a resource pack. Simply instantiate a new PolyRegistry , somehow make sure none of the polys use resource packs, build the PolyMap from the registry, and then you're good to go.","title":"PolyMaps"},{"location":"api/polymaps/#polymaps","text":"The PolyMap is what stores all the polys that PolyMc uses. These Polys in turn define how different things are transformed. By default, PolyMc will generate a single PolyMap using the PolyRegistry . This acts as a builder for the PolyMap. You can add stuff to the PolyRegistry via the registerPolys method in your entrypoint. After the entrypoint is called, PolyMc will iterate the registries and attempt to auto generate polys for anything that doesn't have them.","title":"PolyMaps"},{"location":"api/polymaps/#custom-polymaps","text":"You can actually assign different PolyMaps to different players. The PolyMap used for a player is determined by the PolyMapProvider.EVENT event. example PolyMapProvider . EVENT . register ( player -> { if ( isSpecial ( player )) { return MY_SPECIAL_POLYMAP ; } else { return null ; } }); Using this feature you can also completely disable PolyMc for a player. This is done by returning a NOPPolyMap . Other uses for this include, for example, a PolyMap that doesn't use a resource pack. Simply instantiate a new PolyRegistry , somehow make sure none of the polys use resource packs, build the PolyMap from the registry, and then you're good to go.","title":"Custom PolyMaps"},{"location":"api/resources/","text":"Resources \u00b6 You can append resources when a resource pack is generated in multiple places. Most common is the addToResourcePack function inside a poly. There's also a registerModSpecificResources inside your entrypoint, but it's recommended to use shared values instead. In all of these cases, you'll get two classes; ModdedResources and a PolyMcResourcePack . ModdedResources gives you access to the modded files. You can query for a variety of things. It also allows you to access the client jar, giving you access to Minecraft's own assets. Be very careful with copyright issues. PolyMcResourcePack represents the resource pack that's being generated. You can retrieve files, edit them, and add new files. Retrieving vanilla assets \u00b6 Warning Please use vanilla assets sparingly! PolyMc only copies over very basic stuff that isn't really copyrightable, such as item/generated type item models. The only texture PolyMc copies over is the leather armour texture, which is because all armours need to be inside one file for FancyPants. I highly doubt Mojang is going to take any legal action, after all we're doing some pretty cool stuff, but it might be best to play it safe and give people a heads-up if the resource pack is going to include a bunch of Mojang textures. PolyMc automatically downloads the client jar, so it can access its assets. You can access these assets via the api using the getClientJar and includeClientJar methods inside ModdedResources . The first one will return only assets inside the client jar whilst the latter will include both vanilla assets and other modded assets.","title":"Resources"},{"location":"api/resources/#resources","text":"You can append resources when a resource pack is generated in multiple places. Most common is the addToResourcePack function inside a poly. There's also a registerModSpecificResources inside your entrypoint, but it's recommended to use shared values instead. In all of these cases, you'll get two classes; ModdedResources and a PolyMcResourcePack . ModdedResources gives you access to the modded files. You can query for a variety of things. It also allows you to access the client jar, giving you access to Minecraft's own assets. Be very careful with copyright issues. PolyMcResourcePack represents the resource pack that's being generated. You can retrieve files, edit them, and add new files.","title":"Resources"},{"location":"api/resources/#retrieving-vanilla-assets","text":"Warning Please use vanilla assets sparingly! PolyMc only copies over very basic stuff that isn't really copyrightable, such as item/generated type item models. The only texture PolyMc copies over is the leather armour texture, which is because all armours need to be inside one file for FancyPants. I highly doubt Mojang is going to take any legal action, after all we're doing some pretty cool stuff, but it might be best to play it safe and give people a heads-up if the resource pack is going to include a bunch of Mojang textures. PolyMc automatically downloads the client jar, so it can access its assets. You can access these assets via the api using the getClientJar and includeClientJar methods inside ModdedResources . The first one will return only assets inside the client jar whilst the latter will include both vanilla assets and other modded assets.","title":"Retrieving vanilla assets"},{"location":"api/wizards/","text":"Wizards \u00b6 At an abstract level, wizards are objects that exist in a location in the world and can send packets to players in watching distance. (Ignore the name, I was going to name them block entities, but that's already taken. So we're calling them wizards) You're probably just going to use wizards to spawn armor stands. But technically you could also spawn particles or other entities. Wizards can be attached to both entities and blocks. For example, you could have an aquarium block that spawns a fish when it's placed. Or you could make summon a zombie to represent your modded entity. Basics \u00b6 Wizards have 3 main methods you can override. addPlayer , removePlayer and onMove . addPlayer and removePlayer are called when a player enters/exits the watch distance. If you're spawning entities, you should use addPlayer to send a summon packet and removePlayer to send a remove packet. Use onMove will be called every tick for entities, and when a block is moved (for example with a piston). Use this method to move your entity. Blocks \u00b6 Adding \u00b6 Wizards can be added to blocks via the block's block poly. @Override public boolean hasWizard () { return true ; } @Override public Wizard createWizard ( ServerWorld world , Vec3d pos , WizardState state ) { return new MyWizard ( world , pos , state ); } Note PolyMc automatically handles cases such as when your block is pushed by a piston or if your block is placed inside a falling sand entity. This is why you should implement onMove even for blocks. Entities \u00b6 Attaching a wizard to an entity is similar to attaching one to attaching one to a block. It's recommended to implement EntityWizard instead of Wizard so you have access to the entity. See also: entities . Ticking \u00b6 The onTick function isn't called by default. You'll have to override needsTicking as well. Ticking Example This example spawns a particle in the center of a block every tick. public class MyTickingWizard extends Wizard { @Override public void onTick () { this . getPlayersWatchingChunk (). forEach ( player -> { player . networkHandler . sendPacket ( new ParticleS2CPacket ( ParticleTypes . WAX_ON , false , this . getPosition (). x , this . getPosition (). y + 0.5 , this . getPosition (). z , 0 , 0 , 0 , 0 , 0 )); }); } @Override public boolean needsTicking () { return true ; } } Note The way ticking works will likely be changed in the future to allow for packets to be sent faster than 20hz. Virtual Entity API \u00b6 The virtual entity api is an api to easily send packets as if they come from an actual entity. This gives full control over the packets sent and removes the need to construct an Entity object. Example \u00b6 public class MyWizard extends Wizard { private final VItemFrame virtualItemFrame = new VItemFrame (); @Override public void addPlayer ( ServerPlayerEntity playerEntity ) { virtualItemFrame . spawn ( playerEntity , this . getPosition (), Direction . DOWN ); virtualItemFrame . sendItemStack ( playerEntity , new ItemStack ( Items . STICK )); virtualItemFrame . makeInvisible ( playerEntity ); } @Override public void removePlayer ( ServerPlayerEntity playerEntity ) { virtualItemFrame . remove ( playerEntity ); } @Override public void onMove () { this . getPlayersWatchingChunk (). forEach (( player ) -> virtualItemFrame . move ( player , this . getPosition (), ( byte ) 0 , ( byte ) 0 , true )); } }","title":"Wizards"},{"location":"api/wizards/#wizards","text":"At an abstract level, wizards are objects that exist in a location in the world and can send packets to players in watching distance. (Ignore the name, I was going to name them block entities, but that's already taken. So we're calling them wizards) You're probably just going to use wizards to spawn armor stands. But technically you could also spawn particles or other entities. Wizards can be attached to both entities and blocks. For example, you could have an aquarium block that spawns a fish when it's placed. Or you could make summon a zombie to represent your modded entity.","title":"Wizards"},{"location":"api/wizards/#basics","text":"Wizards have 3 main methods you can override. addPlayer , removePlayer and onMove . addPlayer and removePlayer are called when a player enters/exits the watch distance. If you're spawning entities, you should use addPlayer to send a summon packet and removePlayer to send a remove packet. Use onMove will be called every tick for entities, and when a block is moved (for example with a piston). Use this method to move your entity.","title":"Basics"},{"location":"api/wizards/#blocks","text":"","title":"Blocks"},{"location":"api/wizards/#adding","text":"Wizards can be added to blocks via the block's block poly. @Override public boolean hasWizard () { return true ; } @Override public Wizard createWizard ( ServerWorld world , Vec3d pos , WizardState state ) { return new MyWizard ( world , pos , state ); } Note PolyMc automatically handles cases such as when your block is pushed by a piston or if your block is placed inside a falling sand entity. This is why you should implement onMove even for blocks.","title":"Adding"},{"location":"api/wizards/#entities","text":"Attaching a wizard to an entity is similar to attaching one to attaching one to a block. It's recommended to implement EntityWizard instead of Wizard so you have access to the entity. See also: entities .","title":"Entities"},{"location":"api/wizards/#ticking","text":"The onTick function isn't called by default. You'll have to override needsTicking as well. Ticking Example This example spawns a particle in the center of a block every tick. public class MyTickingWizard extends Wizard { @Override public void onTick () { this . getPlayersWatchingChunk (). forEach ( player -> { player . networkHandler . sendPacket ( new ParticleS2CPacket ( ParticleTypes . WAX_ON , false , this . getPosition (). x , this . getPosition (). y + 0.5 , this . getPosition (). z , 0 , 0 , 0 , 0 , 0 )); }); } @Override public boolean needsTicking () { return true ; } } Note The way ticking works will likely be changed in the future to allow for packets to be sent faster than 20hz.","title":"Ticking"},{"location":"api/wizards/#virtual-entity-api","text":"The virtual entity api is an api to easily send packets as if they come from an actual entity. This gives full control over the packets sent and removes the need to construct an Entity object.","title":"Virtual Entity API"},{"location":"api/wizards/#example","text":"public class MyWizard extends Wizard { private final VItemFrame virtualItemFrame = new VItemFrame (); @Override public void addPlayer ( ServerPlayerEntity playerEntity ) { virtualItemFrame . spawn ( playerEntity , this . getPosition (), Direction . DOWN ); virtualItemFrame . sendItemStack ( playerEntity , new ItemStack ( Items . STICK )); virtualItemFrame . makeInvisible ( playerEntity ); } @Override public void removePlayer ( ServerPlayerEntity playerEntity ) { virtualItemFrame . remove ( playerEntity ); } @Override public void onMove () { this . getPlayersWatchingChunk (). forEach (( player ) -> virtualItemFrame . move ( player , this . getPosition (), ( byte ) 0 , ( byte ) 0 , true )); } }","title":"Example"}]}